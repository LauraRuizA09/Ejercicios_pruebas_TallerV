  /**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
// Directivas de preprocesamiento

#include <stdint.h>
#include <stm32f4xx.h>
#include "stm32_assert.h"
#include "gpio_driver_hal.h"
#include "timer_driver_hal.h"



// Definimos un pin de prubea

GPIO_Handler_t userLed = {0}; //PINA5

GPIO_Handler_t userBoton = {0};
Timer_Handler_t blinkTimer = {0};
Timer_Handler_t reloj1 = {0};

uint8_t botonValue = 0;
uint8_t counter = 0;
uint8_t bandera = 0;
uint8_t led = 0;



/*
 * The main function, where everything happens.
 */
int main(void)
{
	userLed.pGPIOx                           = GPIOA;
	userLed.pinConfig.GPIO_PinNumber         = PIN_5;
	userLed.pinConfig.GPIO_PinMode           = GPIO_MODE_OUT;
	userLed.pinConfig.GPIO_PinOutputType     = GPIO_OTYPE_PUSHPULL;
	userLed.pinConfig.GPIO_PinOutputSpeed    = GPIO_OSPEED_MEDIUM;
	userLed.pinConfig.GPIO_PinPuPdControl    = GPIO_PUPDR_NOTHING;

	/* Cargamos la configuración en los registros que gobiernan el puerto */
	gpio_Config(&userLed);

	gpio_WritePin(&userLed, SET);


    /* Configuramos el pin */
    userBoton.pGPIOx                        = GPIOC;
    userBoton.pinConfig.GPIO_PinNumber      = PIN_5;
    userBoton.pinConfig.GPIO_PinMode        = GPIO_MODE_IN;
    userBoton.pinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;

    /* Cargamos la configuración en los registros que gobiernan el puerto */
    gpio_Config(&userBoton);

    gpio_WritePin(&userBoton, SET);
//
//    blinkTimer.pTIMx								= TIM2;
//    blinkTimer.TIMx_Config.TIMx_Prescaler			= 16000;  //Genera incremento de 1 ms
//    blinkTimer.TIMx_Config.TIMx_Period				= 250; // De la mano con el prescaler,
//    blinkTimer.TIMx_Config.TIMx_mode				= TIMER_UP_COUNTER;
//    blinkTimer.TIMx_Config.TIMx_InterruptEnable		= TIMER_INT_ENABLE;
//
//    /*Configuramos el TIMER*/
//    timer_Config(&blinkTimer);
//
//    /*Encendemos el TIMER*/
//    timer_SetState(&blinkTimer, TIMER_ON);

    reloj1.pTIMx								= TIM4;
    reloj1.TIMx_Config.TIMx_mode				= TIMER_UP_COUNTER;
    reloj1.TIMx_Config.TIMx_Prescaler			= 16000;  //incremento de 1 ms
	reloj1.TIMx_Config.TIMx_Period				= 500;    // cuantos ms va ir el micro
	reloj1.TIMx_Config.TIMx_InterruptEnable 	= TIMER_INT_ENABLE;

	//Configurar el timer//

	timer_Config(&reloj1);

	timer_SetState(&reloj1,  TIMER_ON);


    while (1) {

    	botonValue = gpio_ReadPin(&userBoton);

    	while((!botonValue) & (bandera)){

    		bandera = 0;
    		counter++;
    		botonValue = gpio_ReadPin(&userBoton);
    	}

//    	if(!botonValue){
//
//    		reloj1.TIMx_Config.TIMx_Period = 1000;
//    		timer_SetState(&reloj1, TIMER_OFF);
//    		timer_Config(&reloj1);
//    		timer_SetState(&reloj1, TIMER_ON);
//    	}
//
    	switch(counter){

    	case 0:{
    		break;
    	}

    	case 1:{

			reloj1.TIMx_Config.TIMx_Period = 1000;
			timer_SetState(&reloj1, TIMER_OFF);
			timer_Config(&reloj1);
			timer_SetState(&reloj1, TIMER_ON);

    		break;
    	}

    	case 2:{

			reloj1.TIMx_Config.TIMx_Period = 50;
			timer_SetState(&reloj1, TIMER_OFF);
			timer_Config(&reloj1);
			timer_SetState(&reloj1, TIMER_ON);

    		break;
    	}


    	case 3:{

			reloj1.TIMx_Config.TIMx_Period = 250;
			timer_SetState(&reloj1, TIMER_OFF);
			timer_Config(&reloj1);
			timer_SetState(&reloj1, TIMER_ON);

    		break;
    	}

    	default:{
    		counter = 0;
    		gpio_WritePin(&userLed, SET);
    	}


    }

    return 0;

    }
}

void Timer4_Callback(void){

//	if(!led){
//
//		gpio_WritePin(&userLed, SET);
//	}
//
//	else{
//
//		gpio_WritePin(&userLed, RESET);
//	}
//
	gpio_TooglePin(&userLed);
//	bandera = 1;
}


/*
 * esta funcion sirve para detectar problemas de parametros
 * incorrectos al momento de ejecturar un programa
 */

void assert_failed(uint8_t* file , uint32_t line){
    while(1){
        //problems...
    }
}




